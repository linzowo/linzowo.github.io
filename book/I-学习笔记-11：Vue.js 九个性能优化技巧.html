<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue.js 九个性能优化技巧 | 除夕一梦</title>
    <meta name="generator" content="VuePress 1.5.3">
    <link rel="icon" href="/images/favicon.ico">
    <meta name="description" content="人生路漫漫，你我共前行。">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    <link rel="preload" href="/assets/css/0.styles.d382e733.css" as="style"><link rel="preload" href="/assets/js/app.78869735.js" as="script"><link rel="preload" href="/assets/js/3.b87d3f30.js" as="script"><link rel="preload" href="/assets/js/1.a2d2883b.js" as="script"><link rel="preload" href="/assets/js/32.96890fd5.js" as="script"><link rel="prefetch" href="/assets/js/10.73af3e2b.js"><link rel="prefetch" href="/assets/js/11.33fd2286.js"><link rel="prefetch" href="/assets/js/12.2c03030b.js"><link rel="prefetch" href="/assets/js/13.ef0a44ac.js"><link rel="prefetch" href="/assets/js/14.29141473.js"><link rel="prefetch" href="/assets/js/15.5f6880c1.js"><link rel="prefetch" href="/assets/js/16.17d871c1.js"><link rel="prefetch" href="/assets/js/17.397fa04b.js"><link rel="prefetch" href="/assets/js/18.80d95be4.js"><link rel="prefetch" href="/assets/js/19.63ba86c1.js"><link rel="prefetch" href="/assets/js/20.3db7b909.js"><link rel="prefetch" href="/assets/js/21.198b8d0d.js"><link rel="prefetch" href="/assets/js/22.f3b41891.js"><link rel="prefetch" href="/assets/js/23.6c61811a.js"><link rel="prefetch" href="/assets/js/24.12aebc6e.js"><link rel="prefetch" href="/assets/js/25.dfb2d624.js"><link rel="prefetch" href="/assets/js/26.9632e9fe.js"><link rel="prefetch" href="/assets/js/27.19bba277.js"><link rel="prefetch" href="/assets/js/28.ab74e559.js"><link rel="prefetch" href="/assets/js/29.30ffd748.js"><link rel="prefetch" href="/assets/js/30.3a3bdf43.js"><link rel="prefetch" href="/assets/js/31.f7363c3b.js"><link rel="prefetch" href="/assets/js/33.db696c08.js"><link rel="prefetch" href="/assets/js/34.ff510242.js"><link rel="prefetch" href="/assets/js/35.aa3dbabe.js"><link rel="prefetch" href="/assets/js/36.51bccf4a.js"><link rel="prefetch" href="/assets/js/37.ff60f9d8.js"><link rel="prefetch" href="/assets/js/38.85d6625f.js"><link rel="prefetch" href="/assets/js/4.d24d7b0b.js"><link rel="prefetch" href="/assets/js/5.f0c558b2.js"><link rel="prefetch" href="/assets/js/6.ec6dcdac.js"><link rel="prefetch" href="/assets/js/7.2b4ab631.js"><link rel="prefetch" href="/assets/js/8.d782541f.js"><link rel="prefetch" href="/assets/js/9.452d6822.js">
    <link rel="stylesheet" href="/assets/css/0.styles.d382e733.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-dad8a512><div data-v-dad8a512><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-dad8a512 data-v-dad8a512><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-64685f0e data-v-dad8a512 data-v-dad8a512><h3 class="title" style="display:none;" data-v-64685f0e data-v-64685f0e>除夕一梦</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-64685f0e data-v-64685f0e><input type="password" value="" data-v-64685f0e> <span data-v-64685f0e>Konck! Knock!</span> <button data-v-64685f0e>OK</button></label> <div class="footer" style="display:none;" data-v-64685f0e data-v-64685f0e><span data-v-64685f0e><i class="iconfont reco-theme" data-v-64685f0e></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-64685f0e>vuePress-theme-reco</a></span> <span data-v-64685f0e><i class="iconfont reco-copyright" data-v-64685f0e></i> <a data-v-64685f0e><span data-v-64685f0e>林除夕</span>
            
          <!---->
          2022
        </a></span></div></div> <div class="hide" data-v-dad8a512><header class="navbar" data-v-dad8a512><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">除夕一梦</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      Category
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/B-前端杂谈/" class="nav-link"><i class="iconfont undefined"></i>
  B-前端杂谈
</a></li><li class="dropdown-item"><!----> <a href="/categories/C-JavaScript/" class="nav-link"><i class="iconfont undefined"></i>
  C-JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/categories/E-H5C3/" class="nav-link"><i class="iconfont undefined"></i>
  E-H5C3
</a></li><li class="dropdown-item"><!----> <a href="/categories/F-vue/" class="nav-link"><i class="iconfont undefined"></i>
  F-vue
</a></li><li class="dropdown-item"><!----> <a href="/categories/G-思考/" class="nav-link"><i class="iconfont undefined"></i>
  G-思考
</a></li><li class="dropdown-item"><!----> <a href="/categories/H-项目记录/" class="nav-link"><i class="iconfont undefined"></i>
  H-项目记录
</a></li><li class="dropdown-item"><!----> <a href="/categories/I-学习笔记/" class="nav-link"><i class="iconfont undefined"></i>
  I-学习笔记
</a></li><li class="dropdown-item"><!----> <a href="/categories/Y-有趣/" class="nav-link"><i class="iconfont undefined"></i>
  Y-有趣
</a></li><li class="dropdown-item"><!----> <a href="/categories/z-hexo/" class="nav-link"><i class="iconfont undefined"></i>
  z-hexo
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div><div class="nav-item"><a href="/about/" class="nav-link"><i class="iconfont reco-account"></i>
  About
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      Contact
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/linzowo" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://gitee.com/linzowo/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-mayun"></i>
  gitee
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://www.zhihu.com/people/lin-chu-xi-71" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-zhihu"></i>
  知乎
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-dad8a512></div> <aside class="sidebar" data-v-dad8a512><div class="personal-info-wrapper" data-v-ca798c94 data-v-dad8a512><img src="/images/avatar.jpg" alt="author-avatar" class="personal-img" data-v-ca798c94> <h3 class="name" data-v-ca798c94>
    林除夕
  </h3> <div class="num" data-v-ca798c94><div data-v-ca798c94><h3 data-v-ca798c94>25</h3> <h6 data-v-ca798c94>Article</h6></div> <div data-v-ca798c94><h3 data-v-ca798c94>35</h3> <h6 data-v-ca798c94>Tag</h6></div></div> <hr data-v-ca798c94></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      Category
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/B-前端杂谈/" class="nav-link"><i class="iconfont undefined"></i>
  B-前端杂谈
</a></li><li class="dropdown-item"><!----> <a href="/categories/C-JavaScript/" class="nav-link"><i class="iconfont undefined"></i>
  C-JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/categories/E-H5C3/" class="nav-link"><i class="iconfont undefined"></i>
  E-H5C3
</a></li><li class="dropdown-item"><!----> <a href="/categories/F-vue/" class="nav-link"><i class="iconfont undefined"></i>
  F-vue
</a></li><li class="dropdown-item"><!----> <a href="/categories/G-思考/" class="nav-link"><i class="iconfont undefined"></i>
  G-思考
</a></li><li class="dropdown-item"><!----> <a href="/categories/H-项目记录/" class="nav-link"><i class="iconfont undefined"></i>
  H-项目记录
</a></li><li class="dropdown-item"><!----> <a href="/categories/I-学习笔记/" class="nav-link"><i class="iconfont undefined"></i>
  I-学习笔记
</a></li><li class="dropdown-item"><!----> <a href="/categories/Y-有趣/" class="nav-link"><i class="iconfont undefined"></i>
  Y-有趣
</a></li><li class="dropdown-item"><!----> <a href="/categories/z-hexo/" class="nav-link"><i class="iconfont undefined"></i>
  z-hexo
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div><div class="nav-item"><a href="/about/" class="nav-link"><i class="iconfont reco-account"></i>
  About
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      Contact
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/linzowo" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://gitee.com/linzowo/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-mayun"></i>
  gitee
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://www.zhihu.com/people/lin-chu-xi-71" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-zhihu"></i>
  知乎
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-64685f0e data-v-dad8a512><h3 class="title" style="display:none;" data-v-64685f0e data-v-64685f0e>Vue.js 九个性能优化技巧</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-64685f0e data-v-64685f0e><input type="password" value="" data-v-64685f0e> <span data-v-64685f0e>Konck! Knock!</span> <button data-v-64685f0e>OK</button></label> <div class="footer" style="display:none;" data-v-64685f0e data-v-64685f0e><span data-v-64685f0e><i class="iconfont reco-theme" data-v-64685f0e></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-64685f0e>vuePress-theme-reco</a></span> <span data-v-64685f0e><i class="iconfont reco-copyright" data-v-64685f0e></i> <a data-v-64685f0e><span data-v-64685f0e>林除夕</span>
            
          <!---->
          2022
        </a></span></div></div> <div data-v-dad8a512><main class="page"><div class="page-title" style="display:none;"><h1>Vue.js 九个性能优化技巧</h1> <div data-v-3b7f5bdf><i class="iconfont reco-account" data-v-3b7f5bdf><span data-v-3b7f5bdf>林除夕</span></i> <i class="iconfont reco-date" data-v-3b7f5bdf><span data-v-3b7f5bdf>2021-10-16 12:08:00</span></i> <i class="iconfont reco-eye" data-v-3b7f5bdf><span id="/book/I-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-11%EF%BC%9AVue.js%20%E4%B9%9D%E4%B8%AA%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7.html" data-flag-title="Your Article Title" class="leancloud-visitors" data-v-3b7f5bdf><a class="leancloud-visitors-count" style="font-size:.9rem;font-weight:normal;color:#999;"></a></span></i> <i class="iconfont reco-tag tags" data-v-3b7f5bdf><span class="tag-item" data-v-3b7f5bdf>前端</span><span class="tag-item" data-v-3b7f5bdf>性能优化</span><span class="tag-item" data-v-3b7f5bdf>vue</span></i></div></div> <div class="theme-reco-content content__default" style="display:none;"><p>这篇文章主要参考了 Vue.js 核心成员 Guillaume Chau 在 19 年美国的 Vue conf 分享的主题：9 Performance secrets revealed，分享中提到了九个 Vue.js 性能优化的技巧。</p> <p>我看完他的分享 PPT后，也阅读了相关的项目源码，在深入了解它的优化原理后，把其中一些优化技巧也应用到了我平时的工作中，取得了相当不错的效果。</p> <p>这个分享可谓是非常实用了，但是知道和关注的人似乎并不多，到目前为止，该项目也只有可怜的几百个 star。虽然距大佬的分享已经有两年时间，但是其中的优化技巧并没有过时，为了让更多的人了解并学习到其中的实用技巧，我决定对他的分享做二次加工，详细阐述其中的优化原理，并做一定程度的扩展和延伸。</p> <blockquote><p>本文主要还是针对 Vue.js 2.x 版本</p></blockquote> <p>我建议你在学习这篇文章的时候可以拉取项目的源码，并且本地运行，查看优化前后的效果差异。</p> <h2 id="functional-components"><a href="#functional-components" class="header-anchor">#</a> Functional components</h2> <p>第一个技巧，函数式组件，你可以查看这个在线示例</p> <p>优化前的组件代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;template&gt;
  &lt;div class=&quot;cell&quot;&gt;
    &lt;div v-if=&quot;value&quot; class=&quot;on&quot;&gt;&lt;/div&gt;
    &lt;section v-else class=&quot;off&quot;&gt;&lt;/section&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  props: ['value'],
}
&lt;/script&gt;
</code></pre></div><p>优化后的组件代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;template functional&gt;
  &lt;div class=&quot;cell&quot;&gt;
    &lt;div v-if=&quot;props.value&quot; class=&quot;on&quot;&gt;&lt;/div&gt;
    &lt;section v-else class=&quot;off&quot;&gt;&lt;/section&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre></div><p>然后我们在父组件各渲染优化前后的组件 800 个，并在每一帧内部通过修改数据来触发组件的更新，开启 Chrome 的 Performance 面板记录它们的性能，得到如下结果。</p> <p>优化前：</p> <p><img src="/i-11/0.png" alt="图片"></p> <p>优化后：</p> <p><img src="/i-11/01.png" alt="图片"></p> <p>对比这两张图我们可以看到优化前执行 <code>script</code> 的时间要多于优化后的，而我们知道 JS 引擎是单线程的运行机制，JS 线程会阻塞 UI 线程，所以当脚本执行时间过长，就会阻塞渲染，导致页面卡顿。而优化后的 <code>script</code> 执行时间短，所以它的性能更好。</p> <p>那么，为什么用函数式组件 JS 的执行时间就变短了呢？这要从函数式组件的实现原理说起了，你可以把它理解成一个函数，它可以根据你传递的上下文数据渲染生成一片 DOM。</p> <p>函数式组件和普通的对象类型的组件不同，它不会被看作成一个真正的组件，我们知道在 <code>patch</code> 过程中，如果遇到一个节点是组件 <code>vnode</code>，会递归执行子组件的初始化过程；而函数式组件的 <code>render</code> 生成的是普通的 <code>vnode</code>，不会有递归子组件的过程，因此渲染开销会低很多。</p> <p>因此，函数式组件也不会有状态，不会有响应式数据，生命周期钩子函数这些东西。你可以把它当成把普通组件模板中的一部分 DOM 剥离出来，通过函数的方式渲染出来，是一种在 DOM 层面的复用。</p> <h2 id="child-component-splitting"><a href="#child-component-splitting" class="header-anchor">#</a> Child component splitting</h2> <p>第二个技巧，子组件拆分，你可以查看这个在线示例。</p> <p>优化前的组件代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;template&gt;
  &lt;div :style=&quot;{ opacity: number / 300 }&quot;&gt;
    &lt;div&gt;{{ heavy() }}&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  props: ['number'],
  methods: {
    heavy () {
      const n = 100000
      let result = 0
      for (let i = 0; i &lt; n; i++) {
        result += Math.sqrt(Math.cos(Math.sin(42)))
      }
      return result
    }
  }
}
&lt;/script&gt;
</code></pre></div><p>优化后的组件代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;template&gt;
  &lt;div :style=&quot;{ opacity: number / 300 }&quot;&gt;
    &lt;ChildComp/&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  components: {
    ChildComp: {
      methods: {
        heavy () {
          const n = 100000
          let result = 0
          for (let i = 0; i &lt; n; i++) {
            result += Math.sqrt(Math.cos(Math.sin(42)))
          }
          return result
        },
      },
      render (h) {
        return h('div', this.heavy())
      }
    }
  },
  props: ['number']
}
&lt;/script&gt;
</code></pre></div><p>然后我们在父组件各渲染优化前后的组件 300 个，并在每一帧内部通过修改数据来触发组件的更新，开启 Chrome 的 Performance 面板记录它们的性能，得到如下结果。</p> <p>优化前：</p> <p><img src="/i-11/02.png" alt="图片"></p> <p>优化后：</p> <p><img src="/i-11/03.png" alt="图片"></p> <p>对比这两张图我们可以看到优化后执行 <code>script</code> 的时间要明显少于优化前的，因此性能体验更好。</p> <p>那么为什么会有差异呢，我们来看优化前的组件，示例通过一个 <code>heavy</code> 函数模拟了一个耗时的任务，且这个函数在每次渲染的时候都会执行一次，所以每次组件的渲染都会消耗较长的时间执行 JavaScript。</p> <p>而优化后的方式是把这个耗时任务 <code>heavy</code> 函数的执行逻辑用子组件 <code>ChildComp</code> 封装了，由于 Vue 的更新是组件粒度的，虽然每一帧都通过数据修改导致了父组件的重新渲染，但是 <code>ChildComp</code> 却不会重新渲染，因为它的内部也没有任何响应式数据的变化。所以优化后的组件不会在每次渲染都执行耗时任务，自然执行的 JavaScript 时间就变少了。</p> <p>不过针对这个优化的方式我提出了一些不同的看法，详情可以点开这个 issue，我认为这个场景下的优化用计算属性要比子组件拆分要好。得益于计算属性自身缓存特性，耗时的逻辑也只会在第一次渲染的时候执行，而且使用计算属性也没有额外渲染子组件的开销。</p> <p>在实际工作中，使用计算属性是优化性能的场景会有很多，毕竟它也体现了一种空间换时间的优化思想。</p> <h2 id="local-variables"><a href="#local-variables" class="header-anchor">#</a> Local variables</h2> <p>第三个技巧，局部变量，你可以查看这个在线示例。</p> <p>优化前的组件代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;template&gt;
  &lt;div :style=&quot;{ opacity: start / 300 }&quot;&gt;{{ result }}&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  props: ['start'],
  computed: {
    base () {
      return 42
    },
    result () {
      let result = this.start
      for (let i = 0; i &lt; 1000; i++) {
        result += Math.sqrt(Math.cos(Math.sin(this.base))) + this.base * this.base + this.base + this.base * 2 + this.base * 3
      }
      return result
    },
  },
}
&lt;/script&gt;
</code></pre></div><p>优化后的组件代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;template&gt;
  &lt;div :style=&quot;{ opacity: start / 300 }&quot;&gt;{{ result }}&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  props: ['start'],
  computed: {
    base () {
      return 42
    },
    result ({ base, start }) {
      let result = start
      for (let i = 0; i &lt; 1000; i++) {
        result += Math.sqrt(Math.cos(Math.sin(base))) + base * base + base + base * 2 + base * 3
      }
      return result
    },
  },
}
&lt;/script&gt;
</code></pre></div><p>然后我们在父组件各渲染优化前后的组件 300 个，并在每一帧内部通过修改数据来触发组件的更新，开启 Chrome 的 Performance 面板记录它们的性能，得到如下结果。</p> <p>优化前：</p> <p><img src="/i-11/04.png" alt="图片"></p> <p>优化后：</p> <p><img src="/i-11/05.png" alt="图片"></p> <p>对比这两张图我们可以看到优化后执行 <code>script</code> 的时间要明显少于优化前的，因此性能体验更好。</p> <p>这里主要是优化前后组件的计算属性 <code>result</code> 的实现差异，优化前的组件多次在计算过程中访问 <code>this.base</code>，而优化后的组件会在计算前先用局部变量 <code>base</code> 缓存 <code>this.base</code>，后面则直接访问 <code>base</code>变量。</p> <p>那么为啥这个差异会造成性能上的差异呢，原因是你每次访问 <code>this.base</code> 的时候，由于 <code>this.base</code> 是一个响应式对象，所以会触发它的 <code>getter</code>，进而会执行依赖收集相关逻辑代码。类似的逻辑执行多了，像示例这样，几百次循环更新几百个组件，每个组件触发 <code>computed</code> 重新计算，然后又多次执行依赖收集相关逻辑，性能自然就下降了。</p> <p>从需求上来说，<code>this.base</code> 执行一次依赖收集就够了，因此我们只需要把它的 <code>getter</code> 求值结果返回给局部变量 <code>base</code>，后续再次访问 <code>base</code> 的时候就不会触发 <code>getter</code>，也不会走依赖收集的逻辑了，性能自然就得到了提升。</p> <p>这是一个非常实用的性能优化技巧。因为很多人在开发 Vue.js 项目的时候，每当取变量的时候就习惯性直接写 <code>this.xxx</code> 了，因为大部分人并不会注意到访问 <code>this.xxx</code> 背后做的事情。在访问次数不多的时候，性能问题并没有凸显，但是一旦访问次数变多，比如在一个大循环中多次访问，类似示例这种场景，就会产生性能问题了。</p> <p>我之前给 ZoomUI 的 Table 组件做性能优化的时候，在 <code>render table body</code> 的时候就使用了局部变量的优化技巧，并写了 benchmark 做性能对比：渲染 1000 * 10 的表格，ZoomUI Table 的更新数据重新渲染的性能要比 ElementUI 的 Table 性能提升了近一倍。</p> <h2 id="reuse-dom-with-v-show"><a href="#reuse-dom-with-v-show" class="header-anchor">#</a> Reuse DOM with v-show</h2> <p>第四个技巧，使用 <code>v-show</code> 复用 DOM，你可以查看这个在线示例。</p> <p>优化前的组件代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;template functional&gt;
  &lt;div class=&quot;cell&quot;&gt;
    &lt;div v-if=&quot;props.value&quot; class=&quot;on&quot;&gt;
      &lt;Heavy :n=&quot;10000&quot;/&gt;
    &lt;/div&gt;
    &lt;section v-else class=&quot;off&quot;&gt;
      &lt;Heavy :n=&quot;10000&quot;/&gt;
    &lt;/section&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre></div><p>优化后的组件代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;template functional&gt;
  &lt;div class=&quot;cell&quot;&gt;
    &lt;div v-show=&quot;props.value&quot; class=&quot;on&quot;&gt;
      &lt;Heavy :n=&quot;10000&quot;/&gt;
    &lt;/div&gt;
    &lt;section v-show=&quot;!props.value&quot; class=&quot;off&quot;&gt;
      &lt;Heavy :n=&quot;10000&quot;/&gt;
    &lt;/section&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre></div><p>然后我们在父组件各渲染优化前后的组件 200 个，并在每一帧内部通过修改数据来触发组件的更新，开启 Chrome 的 Performance 面板记录它们的性能，得到如下结果。</p> <p>优化前：</p> <p><img src="/i-11/06.png" alt="图片"></p> <p>优化后：</p> <p><img src="/i-11/07.png" alt="图片"></p> <p>对比这两张图我们可以看到优化后执行 <code>script</code> 的时间要明显少于优化前的，因此性能体验更好。</p> <p>优化前后的主要区别是用 <code>v-show</code> 指令替代了 <code>v-if</code> 指令来替代组件的显隐，虽然从表现上看，<code>v-show</code> 和 <code>v-if</code> 类似，都是控制组件的显隐，但内部实现差距还是很大的。</p> <p><code>v-if</code> 指令在编译阶段就会编译成一个三元运算符，条件渲染，比如优化前的组件模板经过编译后生成如下渲染函数：</p> <div class="language- extra-class"><pre class="language-text"><code>function render() {
  with(this) {
    return _c('div', {
      staticClass: &quot;cell&quot;
    }, [(props.value) ? _c('div', {
      staticClass: &quot;on&quot;
    }, [_c('Heavy', {
      attrs: {
        &quot;n&quot;: 10000
      }
    })], 1) : _c('section', {
      staticClass: &quot;off&quot;
    }, [_c('Heavy', {
      attrs: {
        &quot;n&quot;: 10000
      }
    })], 1)])
  }
}
</code></pre></div><p>当条件 <code>props.value</code> 的值变化的时候，会触发对应的组件更新，对于 <code>v-if</code> 渲染的节点，由于新旧节点 <code>vnode</code> 不一致，在核心 diff 算法比对过程中，会移除旧的 <code>vnode</code> 节点，创建新的 <code>vnode</code> 节点，那么就会创建新的 <code>Heavy</code> 组件，又会经历 <code>Heavy</code> 组件自身初始化、渲染 <code>vnode</code>、<code>patch</code> 等过程。</p> <p>因此使用 <code>v-if</code> 每次更新组件都会创建新的 <code>Heavy</code> 子组件，当更新的组件多了，自然就会造成性能压力。</p> <p>而当我们使用 <code>v-show</code> 指令，优化后的组件模板经过编译后生成如下渲染函数：</p> <div class="language- extra-class"><pre class="language-text"><code>function render() {
  with(this) {
    return _c('div', {
      staticClass: &quot;cell&quot;
    }, [_c('div', {
      directives: [{
        name: &quot;show&quot;,
        rawName: &quot;v-show&quot;,
        value: (props.value),
        expression: &quot;props.value&quot;
      }],
      staticClass: &quot;on&quot;
    }, [_c('Heavy', {
      attrs: {
        &quot;n&quot;: 10000
      }
    })], 1), _c('section', {
      directives: [{
        name: &quot;show&quot;,
        rawName: &quot;v-show&quot;,
        value: (!props.value),
        expression: &quot;!props.value&quot;
      }],
      staticClass: &quot;off&quot;
    }, [_c('Heavy', {
      attrs: {
        &quot;n&quot;: 10000
      }
    })], 1)])
  }
}
</code></pre></div><p>当条件 <code>props.value</code> 的值变化的时候，会触发对应的组件更新，对于 <code>v-show</code> 渲染的节点，由于新旧 <code>vnode</code> 一致，它们只需要一直 <code>patchVnode</code> 即可，那么它又是怎么让 DOM 节点显示和隐藏的呢？</p> <p>原来在 <code>patchVnode</code> 过程中，内部会对执行 <code>v-show</code> 指令对应的钩子函数 <code>update</code>，然后它会根据 <code>v-show</code> 指令绑定的值来设置它作用的 DOM 元素的 <code>style.display</code> 的值控制显隐。</p> <p>因此相比于 <code>v-if</code> 不断删除和创建函数新的 DOM，<code>v-show</code> 仅仅是在更新现有 DOM 的显隐值，所以 <code>v-show</code> 的开销要比 <code>v-if</code> 小的多，当其内部 DOM 结构越复杂，性能的差异就会越大。</p> <p>但是 <code>v-show</code> 相比于 <code>v-if</code> 的性能优势是在组件的更新阶段，如果仅仅是在初始化阶段，<code>v-if</code> 性能还要高于 <code>v-show</code>，原因是在于它仅仅会渲染一个分支，而 <code>v-show</code> 把两个分支都渲染了，通过 <code>style.display</code> 来控制对应 DOM 的显隐。</p> <p>在使用 <code>v-show</code> 的时候，所有分支内部的组件都会渲染，对应的生命周期钩子函数都会执行，而使用 <code>v-if</code> 的时候，没有命中的分支内部的组件是不会渲染的，对应的生命周期钩子函数都不会执行。</p> <p>因此你要搞清楚它们的原理以及差异，才能在不同的场景使用适合的指令。</p> <h2 id="keepalive"><a href="#keepalive" class="header-anchor">#</a> KeepAlive</h2> <p>第五个技巧，使用 <code>KeepAlive</code> 组件缓存 DOM，你可以查看这个在线示例。</p> <p>优化前的组件代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;router-view/&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre></div><p>优化后的组件代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;keep-alive&gt;
      &lt;router-view/&gt;
    &lt;/keep-alive&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre></div><p>我们点击按钮在 Simple page 和 Heavy Page 之间切换，会渲染不同的视图，其中 Heavy Page 的渲染非常耗时。我们开启 Chrome 的 Performance 面板记录它们的性能，然后分别在优化前后执行如上的操作，会得到如下结果。</p> <p>优化前：</p> <p><img src="/i-11/08.png" alt="图片"></p> <p><img src="/i-11/09.png" alt="图片"></p> <p>优化后：</p> <p><img src="/i-11/010.png" alt="图片"></p> <p><img src="/i-11/011.png" alt="图片"></p> <p>对比这两张图我们可以看到优化后执行 <code>script</code> 的时间要明显少于优化前的，因此性能体验更好。</p> <p>在非优化场景下，我们每次点击按钮切换路由视图，都会重新渲染一次组件，渲染组件就会经过组件初始化，<code>render</code>、<code>patch</code> 等过程，如果组件比较复杂，或者嵌套较深，那么整个渲染耗时就会很长。</p> <p>而在使用 <code>KeepAlive</code> 后，被 <code>KeepAlive</code> 包裹的组件在经过第一次渲染后，的 <code>vnode</code> 以及 DOM 都会被缓存起来，然后再下一次再次渲染该组件的时候，直接从缓存中拿到对应的 <code>vnode</code> 和 DOM，然后渲染，并不需要再走一次组件初始化，<code>render</code> 和 <code>patch</code> 等一系列流程，减少了 <code>script</code> 的执行时间，性能更好。</p> <p>但是使用 <code>KeepAlive</code> 组件并非没有成本，因为它会占用更多的内存去做缓存，这是一种典型的空间换时间优化思想的应用。</p> <h2 id="deferred-features"><a href="#deferred-features" class="header-anchor">#</a> Deferred features</h2> <p>第六个技巧，使用 <code>Deferred</code> 组件延时分批渲染组件，你可以查看这个在线示例。</p> <p>优化前的组件代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;template&gt;
  &lt;div class=&quot;deferred-off&quot;&gt;
    &lt;VueIcon icon=&quot;fitness_center&quot; class=&quot;gigantic&quot;/&gt;

    &lt;h2&gt;I'm an heavy page&lt;/h2&gt;

    &lt;Heavy v-for=&quot;n in 8&quot; :key=&quot;n&quot;/&gt;

    &lt;Heavy class=&quot;super-heavy&quot; :n=&quot;9999999&quot;/&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre></div><p>优化后的组件代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;template&gt;
  &lt;div class=&quot;deferred-on&quot;&gt;
    &lt;VueIcon icon=&quot;fitness_center&quot; class=&quot;gigantic&quot;/&gt;

    &lt;h2&gt;I'm an heavy page&lt;/h2&gt;

    &lt;template v-if=&quot;defer(2)&quot;&gt;
      &lt;Heavy v-for=&quot;n in 8&quot; :key=&quot;n&quot;/&gt;
    &lt;/template&gt;

    &lt;Heavy v-if=&quot;defer(3)&quot; class=&quot;super-heavy&quot; :n=&quot;9999999&quot;/&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import Defer from '@/mixins/Defer'

export default {
  mixins: [
    Defer(),
  ],
}
&lt;/script&gt;
</code></pre></div><p>我们点击按钮在 Simple page 和 Heavy Page 之间切换，会渲染不同的视图，其中 Heavy Page 的渲染非常耗时。我们开启 Chrome 的 Performance 面板记录它们的性能，然后分别在优化前后执行如上的操作，会得到如下结果。</p> <p>优化前：</p> <p><img src="/i-11/012.png" alt="图片"></p> <p>优化后：</p> <p><img src="/i-11/013.png" alt="图片"></p> <p>对比这两张图我们可以发现，优化前当我们从 Simple Page 切到 Heavy Page 的时候，在一次 Render 接近结尾的时候，页面渲染的仍然是 Simple Page，会给人一种页面卡顿的感觉。而优化后当我们从 Simple Page 切到 Heavy Page 的时候，在一次 Render 靠前的位置页面就已经渲染了 Heavy Page 了，并且 Heavy Page 是渐进式渲染出来的。</p> <p>优化前后的差距主要是后者使用了 <code>Defer</code> 这个 <code>mixin</code>，那么它具体是怎么工作的，我们来一探究竟：</p> <div class="language- extra-class"><pre class="language-text"><code>export default function (count = 10) {
  return {
    data () {
      return {
        displayPriority: 0
      }
    },

    mounted () {
      this.runDisplayPriority()
    },

    methods: {
      runDisplayPriority () {
        const step = () =&gt; {
          requestAnimationFrame(() =&gt; {
            this.displayPriority++
            if (this.displayPriority &lt; count) {
              step()
            }
          })
        }
        step()
      },

      defer (priority) {
        return this.displayPriority &gt;= priority
      }
    }
  }
}
</code></pre></div><p><code>Defer</code> 的主要思想就是把一个组件的一次渲染拆成多次，它内部维护了 <code>displayPriority</code> 变量，然后在通过 <code>requestAnimationFrame</code> 在每一帧渲染的时候自增，最多加到 <code>count</code>。然后使用 <code>Defer mixin</code> 的组件内部就可以通过 <code>v-if=&quot;defer(xxx)&quot;</code> 的方式来控制在 <code>displayPriority</code> 增加到 <code>xxx</code> 的时候渲染某些区块了。</p> <p>当你有渲染耗时的组件，使用 <code>Deferred</code> 做渐进式渲染是不错的注意，它能避免一次 <code>render</code> 由于 JS 执行时间过长导致渲染卡住的现象。</p> <h2 id="time-slicing"><a href="#time-slicing" class="header-anchor">#</a> Time slicing</h2> <p>第七个技巧，使用 <code>Time slicing</code> 时间片切割技术，你可以查看这个在线示例。</p> <p>优化前的代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>fetchItems ({ commit }, { items }) {
  commit('clearItems')
  commit('addItems', items)
}
</code></pre></div><p>优化后的代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>fetchItems ({ commit }, { items, splitCount }) {
  commit('clearItems')
  const queue = new JobQueue()
  splitArray(items, splitCount).forEach(
    chunk =&gt; queue.addJob(done =&gt; {
      // 分时间片提交数据
      requestAnimationFrame(() =&gt; {
        commit('addItems', chunk)
        done()
      })
    })
  )
  await queue.start()
}
</code></pre></div><p>我们先通过点击 <code>Genterate items</code> 按钮创建 10000 条假数据，然后分别在开启和关闭 <code>Time-slicing</code> 的情况下点击 <code>Commit items</code> 按钮提交数据，开启 Chrome 的 Performance 面板记录它们的性能，会得到如下结果。</p> <p>优化前：</p> <p><img src="/i-11/014.png" alt="图片"></p> <p>优化后：</p> <p><img src="/i-11/015.png" alt="图片"></p> <p>对比这两张图我们可以发现，优化前总的 <code>script</code> 执行时间要比优化后的还要少一些，但是从实际的观感上看，优化前点击提交按钮，页面会卡死 1.2 秒左右，在优化后，页面不会完全卡死，但仍然会有渲染卡顿的感觉。</p> <p>那么为什么在优化前页面会卡死呢？因为一次性提交的数据过多，内部 JS 执行时间过长，阻塞了 UI 线程，导致页面卡死。</p> <p>优化后，页面仍有卡顿，是因为我们拆分数据的粒度是 1000 条，这种情况下，重新渲染组件仍然有压力，我们观察 fps 只有十几，会有卡顿感。通常只要让页面的 fps 达到 60，页面就会非常流畅，如果我们把数据拆分粒度变成 100 条，基本上 fps 能达到 50 以上，虽然页面渲染变流畅了，但是完成 10000 条数据总的提交时间还是变长了。</p> <p>使用 <code>Time slicing</code>技术可以避免页面卡死，通常我们在这种耗时任务处理的时候会加一个 <code>loading</code> 效果，在这个示例中，我们可以开启 <code>loading animation</code>，然后提交数据。对比发现，优化前由于一次性提交数据过多，JS 一直长时间运行，阻塞 UI 线程，这个 <code>loading</code> 动画是不会展示的，而优化后，由于我们拆成多个时间片去提交数据，单次 JS 运行时间变短了，这样 <code>loading</code> 动画就有机会展示了。</p> <blockquote><p>这里要注意的一点，虽然我们拆时间片使用了 <code>requestAnimationFrame</code> API，但是使用 <code>requestAnimationFrame</code> 本身是不能保证满帧运行的，<code>requestAnimationFrame</code> 保证的是在浏览器每一次重绘后会执行对应传入的回调函数，想要保证满帧，只能让 JS 在一个 Tick 内的运行时间不超过 17ms。</p></blockquote> <h2 id="non-reactive-data"><a href="#non-reactive-data" class="header-anchor">#</a> Non-reactive data</h2> <p>第八个技巧，使用 <code>Non-reactive data</code> ，你可以查看这个在线示例。</p> <p>优化前代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>const data = items.map(
  item =&gt; ({
    id: uid++,
    data: item,
    vote: 0
  })
)
</code></pre></div><p>优化后代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>const data = items.map(
  item =&gt; optimizeItem(item)
)

function optimizeItem (item) {
  const itemData = {
    id: uid++,
    vote: 0
  }
  Object.defineProperty(itemData, 'data', {
    // Mark as non-reactive
    configurable: false,
    value: item
  })
  return itemData
}
</code></pre></div><p>还是前面的示例，我们先通过点击 <code>Genterate items</code> 按钮创建 10000 条假数据，然后分别在开启和关闭 <code>Partial reactivity</code> 的情况下点击 <code>Commit items</code> 按钮提交数据，开启 Chrome 的 Performance 面板记录它们的性能，会得到如下结果。</p> <p>优化前：</p> <p><img src="/i-11/016.png" alt="图片"></p> <p>优化后：</p> <p><img src="/i-11/017.png" alt="图片"></p> <p>对比这两张图我们可以看到优化后执行 <code>script</code> 的时间要明显少于优化前的，因此性能体验更好。</p> <p>之所以有这种差异，是因为内部提交的数据的时候，会默认把新提交的数据也定义成响应式，如果数据的子属性是对象形式，还会递归让子属性也变成响应式，因此当提交数据很多的时候，这个过程就变成了一个耗时过程。</p> <p>而优化后我们把新提交的数据中的对象属性 <code>data</code> 手动变成了 <code>configurable</code> 为 <code>false</code>，这样内部在 <code>walk</code> 时通过 <code>Object.keys(obj)</code> 获取对象属性数组会忽略 <code>data</code>，也就不会为 <code>data</code> 这个属性 <code>defineReactive</code>，由于 <code>data</code> 指向的是一个对象，这样也就会减少递归响应式的逻辑，相当于减少了这部分的性能损耗。数据量越大，这种优化的效果就会更明显。</p> <p>其实类似这种优化的方式还有很多，比如我们在组件中定义的一些数据，也不一定都要在 <code>data</code> 中定义。有些数据我们并不是用在模板中，也不需要监听它的变化，只是想在组件的上下文中共享这个数据，这个时候我们可以仅仅把这个数据挂载到组件实例 <code>this</code> 上，例如：</p> <div class="language- extra-class"><pre class="language-text"><code>export default {
  created() {
    this.scroll = null
  },
  mounted() {
    this.scroll = new BScroll(this.$el)
  }
}
</code></pre></div><p>这样我们就可以在组件上下文中共享 <code>scroll</code> 对象了，即使它不是一个响应式对象。</p> <h2 id="virtual-scrolling"><a href="#virtual-scrolling" class="header-anchor">#</a> Virtual scrolling</h2> <p>第九个技巧，使用 <code>Virtual scrolling</code> ，你可以查看这个在线示例。</p> <p>优化前组件的代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div class=&quot;items no-v&quot;&gt;
  &lt;FetchItemViewFunctional
    v-for=&quot;item of items&quot;
    :key=&quot;item.id&quot;
    :item=&quot;item&quot;
    @vote=&quot;voteItem(item)&quot;
  /&gt;
&lt;/div&gt;
</code></pre></div><p>优化后代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;recycle-scroller
  class=&quot;items&quot;
  :items=&quot;items&quot;
  :item-size=&quot;24&quot;
&gt;
  &lt;template v-slot=&quot;{ item }&quot;&gt;
    &lt;FetchItemView
      :item=&quot;item&quot;
      @vote=&quot;voteItem(item)&quot;
    /&gt;
  &lt;/template&gt;
&lt;/recycle-scroller&gt;
</code></pre></div><p>还是前面的示例，我们需要开启 <code>View list</code>，然后点击 <code>Genterate items</code> 按钮创建 10000 条假数据（注意，线上示例最多只能创建 1000 条数据，实际上 1000 条数据并不能很好地体现优化的效果，所以我修改了源码的限制，本地运行，创建了 10000 条数据），然后分别在 <code>Unoptimized</code> 和 <code>RecycleScroller</code> 的情况下点击 <code>Commit items</code> 按钮提交数据，滚动页面，开启 Chrome 的 Performance 面板记录它们的性能，会得到如下结果。</p> <p>优化前：</p> <p><img src="/i-11/018.png" alt="图片"></p> <p>优化后：</p> <p><img src="/i-11/019.png" alt="图片"></p> <p>对比这两张图我们发现，在非优化的情况下，10000 条数据在滚动情况下 fps 只有个位数，在非滚动情况下也就十几，原因是非优化场景下渲染的 DOM 太多，渲染本身的压力很大。优化后，即使 10000 条数据，在滚动情况下的 fps 也能有 30 多，在非滚动情况下可以达到 60 满帧。</p> <p>之所以有这个差异，是因为虚拟滚动的实现方式：是只渲染视口内的 DOM。这样总共渲染的 DOM 数量就很少了，自然性能就会好很多。</p> <p>虚拟滚动组件也是 Guillaume Chau 写的，感兴趣的同学可以去研究它的源码实现。它的基本原理就是监听滚动事件，动态更新需要显示的 DOM 元素，计算出它们在视图中的位移。</p> <p>虚拟滚动组件也并非没有成本，因为它需要在滚动的过程中实时去计算，所以会有一定的 <code>script</code> 执行的成本。因此如果列表的数据量不是很大的情况，我们使用普通的滚动就足够了。</p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>通过这篇文章，我希望你能了解到 Vue.js 的九种性能优化技巧，并能运用到实际的开发项目中。除了上述技巧之外，还有懒加载图片、懒加载组件、异步组件等等常用的性能优化手段。</p> <p>在做性能优化前，我们需要分析性能的瓶颈在哪，才能因地制宜。另外，性能优化都需要数据支撑的，你在做任何性能优化前，需要先采集优化前的数据，这样优化后才能够通过数据对比看到优化的效果。</p> <p>希望你在日后的开发过程中，不再只满足于实现需求，写每一行代码的时候，都能思考它可能产生的性能方面的影响。</p> <h2 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h2> <p>[1] vue-9-perf-secrets slidse：https://slides.com/akryum/vueconfus-2019</p> <p>[2] vue-9-perf-secrets 分享演讲视频：https://www.vuemastery.com/conferences/vueconf-us-2019/9-performance-secrets-revealed/</p> <p>[3] vue-9-perf-secrets 项目源码：https://github.com/Akryum/vue-9-perf-secrets</p> <p>[4] vue-9-perf-secrets 在线演示地址：https://vue-9-perf-secrets.netlify.app/</p> <p>[5] vue-9-perf-secrets 讨论 issue：https://github.com/Akryum/vue-9-perf-secrets/issues/1</p> <p>[6] vue-virtual-scroller 项目源码：https://github.com/Akryum/vue-virtual-scroller</p></div> <footer class="page-edit" style="display:none;"><!----> <!----></footer> <!----> <!----> <!----></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div><div id="live2d-widget" class="live2d-widget-container" style="position:fixed;left:20px;bottom:0px;width:135px;height:300px;z-index:99999;opacity:0.8;pointer-events:none;"><canvas id="live2d_canvas" width="135" height="300" class="live2d_canvas" style="position:absolute;left:0px;top:0px;width:135px;height:300px;"></canvas></div></div></div>
    <script src="/assets/js/app.78869735.js" defer></script><script src="/assets/js/3.b87d3f30.js" defer></script><script src="/assets/js/1.a2d2883b.js" defer></script><script src="/assets/js/32.96890fd5.js" defer></script>
  </body>
</html>
